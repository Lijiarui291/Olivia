//A: 大整数乘法
//计算两个大整数的积
//输入  第1行是一个整数n，表示随后有n组数据
//每组数据占一行，包含两个整数a b，用空格隔开 0 <= a,b <= 10^500(10的500次方)
//对每组数据输出两个整数的积，并换行 
#include <stdio.h>
#include <math.h>
#include <string.h>
#define M 1000
char s1[M], s2[M], s[M];
int a[100][M], b[100][M], c[100][M];

int main() {
	int B;  //输入的组数
	int h, i, j, m, n; //m、n为字符串s1、s2长度
	int k[100];  //将每一个m+n存入数组中
	scanf("%d", &B);
	memset(c, 0, sizeof(c));  //将数组c中元素全部初始化为0，没有此步骤也可以(因为数组c此时为全局变量，其中元素已经自动初始化为0)
	for (h = 0; h < B; h++) {
		scanf("%s%s", s1, s2);
		n = strlen(s1);
		m = strlen(s2);
		k[h] = n + m;	//保证相乘后的位数不会大于k【h】
		//把字符串s1和s2逆序用数字排列
		for (i = 0; i < n; i++)
			a[h][i] = s1[n - i - 1] - '0';  //隐式转化，0为int型（4字节），s[i]为char型(1字节)，故最终转化为int型
		for (i = 0; i < m; i++)
			b[h][i] = s2[m - 1 - i] - '0';
		//乘运算
		for (i = 0; i < n; i++)
			for (j = 0; j < m; j++)
				c[h][i + j] += a[h][i] * b[h][j];
		//进位
		for (i = 0; i <= k[h]; i++) {
			if (c[h][i] >= 10) {
				c[h][i + 1] += c[h][i] / 10;
				c[h][i] %= 10;
			}
		}
	}
	for (h = 0; h < B; h++) {
		//除去多余的0，若无此步骤，则输出20*3的结果为060，输出20*6的结果为120；
		i = k[h];
		while (c[h][i] == 0)
			i--;
		//逆序打印c[][]
		while (i >= 0)
			printf("%d", c[h][i]), i--;
		printf("\n");
	}
	return 0;
}

//B:字符串右移问题 
#include <stdio.h>
#include <string.h>
int main(){
	//将一个字符串循环向左移M（M>=0）个字符位置，
	//即将字符串A中的数据由（A0 A1……AN-1）
	//变换为（AN-M …… AN-1 A0 A1……AN-M-1）
	//（N是字符串的长度，最后M个数循环移至最前面的M个位置）
	//每个输入包含一个测试用例，第1行输入M（M>=0）；第2行为输入字符串，长度不超过200。
    int M, i;
	int j = 0;//声明输入的希望左移的字符位置和数组的脚标 
	//建立数组来进行处理（冒泡排序作改编）
	char A[200];
	int a = 200;
	
	
	scanf("%d\n", &M);
	fgets(A, a, stdin);
    A[strlen(A)-1]='\0';
    int len = strlen(A);
	
	for(i = len - M;i <= len - 1;i++){
	  
	  printf("%c", A[j + len - M]);
	  j++;}

	for(i = 0;i < len - M;i++){
		printf("%c", A[i]);
	}
	  
	//for(int i = len - m; i < len; i++)ss[i - len +  m] = s[i];
	//for(int i = 0; i < len - m; i++)ss[i + m] = s[i];
	 
return 0;}
