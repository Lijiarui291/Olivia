1.对于一个有正数和负数的数组，将其中所有小于0的元素放到所有大于0的元素的前面。使用的算法是:从左右两个方向扫描数组，从左向右找到大于等于0的元素，从右向左找到小于0的元素，将两者交换
#include<iostream>
#include<algorithm>
using namespace std;
class ARR {
public:
	ARR(int x[], int size);//构造函数，用参数size初始化n,用x数组初始化a数组
	void change();//使用以上算法，完成调换数组元素的工作
	void show();//输出a数组的值
private:
	int n;//数组实际元素个数
	int a[100];//初始时存放原始数据，最终存放交换后的数组
};
ARR::ARR(int x[], int size) {
	for (int i = 0;i < size;i++) {
		a[i] = x[i];
	}
	n = size;
}
void ARR::show() {
	for (int i = 0;i < n;i++) {
		cout << a[i] << " ";
	}
	cout << endl;
}
void ARR::change() {
	int tempon[20];//大于等于0
	int tempdown[20];//小于0
	int ii = 0;
	int iii = 0;
	for (int i = 0;i < n;i++) {//从左往右扫
		for (int j = n - 1;j >= 0;j--) {//从右往左扫
			if (a[i] >= 0 && a[j] < 0 && j > i) {
				int t = a[i];
				a[i] = a[j];
				a[j] = t;
				//cout << t << "<->" << a[i] << " ";
				break;
			}
		}
	}
}
int main() {
	//int b[10];
	/*for (int i = 0;i < 10;i++) {
		cin >> b[i];
	}*/
	int b[10] = { 1,-3,-1,3,2,4,-4,5,-5,-2 };
	ARR v(b, 10);
	v.show();
	v.change();
	v.show();
	return 0;
} 
